---
title: "07-Sex DE (02, 04-06) Xenium-Visium comparison"
output: html_document
date: "2024-08-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height = 10,fig.width = 7,include = FALSE)
#### sets tab autocompletion for directories to begin from the directory containing the .Rproj session, instead of the script's directory if different
knitr::opts_knit$set(root.dir = here::here())

library(data.table)

## rstudio GUI tweaks
require(colorout)
ColorOut()
options("styler.addins_style_transformer" = "biocthis::bioc_style()")
##

```

### read in xenium cell type DE results, domain DE results, cell type DE in high-conf domain results, nuclear counts DE results; Visium k=15 bayesspace sex DE results with VMH and ARC domains individually and with them collapsed

```{r}
xencellarc <- fread("processed-data/08_VMH-ARC cell type sex DE within domains/02a-4ARCtypesmoothed_withinARC_celltypeSexDE.txt")
xencellvmh <- fread("processed-data/08_VMH-ARC cell type sex DE within domains/02b-4ARCtypesmoothed_withinVMH_celltypeSexDE.txt")

# domain-wide sex DE
xendomain <- fread("processed-data/08_VMH-ARC cell type sex DE within domains/04-4typeARC-and-dualassignVMH_domainwise_sexDE.txt")

# cell type DE in high conf domains
xenhiconfarc <- fread("processed-data/08_VMH-ARC cell type sex DE within domains/05a-4celltypeARCsmoothing_hiconf-interior96pctOfARC_celltypeSexDE.txt")
xenhiconfvmh <- fread("processed-data/08_VMH-ARC cell type sex DE within domains/05b-4celltypeARCsmoothing_hiconf-interior96pctOfVMH_celltypeSexDE.txt")

# nuclear counts-based cell type DE
xennucarc <- fread("processed-data/08_VMH-ARC cell type sex DE within domains/06a-4celltypeARCsmoothing_celltypeSexDE_nuclearcounts_inARC.txt")
xennucvmh <- fread("processed-data/08_VMH-ARC cell type sex DE within domains/06b-4celltypeARCsmoothing_celltypeSexDE_nuclearcounts_inVMH.txt")

## read in visium and reorganinze to match xenium de result table contents
## subset to VMH and ARC domains in these two
visdom <- fread("../spatial_HYP/processed-data/09-Sex DE/01b-voomLmFit_nnsvg10-HmnylmbNA-BS-15-singleClusts.txt")
visdom <- visdom[assay%in% c("X4","X6","X7","X12")]
visdom[assay=="X4",assay:="ARC.1"]
visdom[assay=="X6",assay:="ARC.2"]
visdom[assay=="X7",assay:="VMH.1"]
visdom[assay=="X12",assay:="VMH.2"]

visclps <- fread("../spatial_HYP/processed-data/09-Sex DE/01c-voomLmFit_nnsvg10-HmnylmbNA-BS-15-VMHARCclpsd.txt")
visclps <- visclps[assay %in% c("VMH","ARC")]

## get a list of these together for streamlined operations
des <- list(xencellarc,xencellvmh,xenhiconfarc,xenhiconfvmh,xennucarc,xennucvmh,xendomain,visdom,visclps)
names(des) <- c("xencellarc","xencellvmh","xenhiconfarc","xenhiconfvmh","xennucarc","xennucvmh","xendomain","visdom","visclps")
```


extract t stat and gene from each and merge
```{r}
## assay corresponds to cell type/cluster; subset to VMH/ARC clusters for xenium
des[1:6] <- lapply(des[1:6],FUN=function(x){
    x <- x[cluster_annotated %in% c(paste0("VMH_",c(1:3)),paste0("ARC_",c(1:5)))]
})

## subset visiums to single/joint arc/vmh domains
des[8:9] <- lapply(des[8:9],FUN=function(x){
    x <- x[assay %in% c("VMH","ARC","VMH.1","VMH.2","ARC.1","ARC.2")]
})

## make the cluster column uniform across datasets
des[1:6] <- lapply(des[1:6],FUN=function(x){setnames(x,"cluster_annotated","assay")})
des[[7]] <- setnames(des[[7]],"domain","assay")


## label the xenium/visium clusters at a generic level 
des[1:7] <- lapply(des[1:7],FUN=function(x){x[,assay:=paste0(assay,"_xen")]})
des[8:9] <- lapply(des[8:9],FUN=function(x){x[,assay:=paste0(assay,"_vis")]})



### merge all into one big gene-cell-cluster-Male-vs-Female-t-stat table
i<-1
for (i in c(1:length(des))){
    tstatcol <- grep(names(des[[i]]),pattern="^t.*$",value=T)
    getnames <- c("gene_name","assay",tstatcol)
    tmp <- des[[i]][,..getnames]
    # set a unique t stat column name based on the analysis
    tstatreplace <- paste0("t_",names(des)[i])
    setnames(tmp,tstatcol,tstatreplace)

    if(i==1){
        setnames(tmp,"assay","assay_xen")
        detabs <- copy(tmp)
    }
    # merge xenium rows by cluster and gene
    else if (i<=6){
        setnames(tmp,"assay","assay_xen")
        detabs <- merge.data.table(detabs,tmp,by=c("gene_name","assay_xen"),all=T)
    }
    else if (i==7){setnames(tmp,"assay","assay_xendom")
                detabs <- merge.data.table(detabs,tmp,by="gene_name",all=T,allow.cartesian=T)}
    # subset visium results to xenium genes, merge by gene, allow multi-pairing so that each gene-cell type row from visium is paired to each from xenium
    else if (i>7){
        tmp <- tmp[gene_name %in% detabs$gene_name]
        setnames(tmp,"assay",paste0("assay_",names(des)[i]))
            detabs <- merge.data.table(detabs,tmp,by="gene_name",all=T,allow.cartesian=T)
    }
    rm(tmp,tstatcol,tstatreplace,getnames)
}
rm(i)
```

### past this point, I'm totally stuck on how to get back a table with just three columns linking unique analyses (but only comparing across analysis types for matched cluster(s), e.g. ARC_1_xenhiconf vs. ARC_1_xennuc). the  below code sort of gets there but information gets lost and flipped around in the generation of the "correct" labels so it's pretty useless.

### DO NOT USE -- ERRONEOUS RESULTS ###

```{r}
# combs <- expand.grid(grep(names(detabs),pattern="t_",value=T),grep(names(detabs),pattern="t_",value=T))
# 
# combs <- as.data.table(combs)
# setnames(combs,c("stat1","stat2"))
# combs[,stat1:=as.character(stat1)]
# combs[,stat2:=as.character(stat2)]
# 
# ## specify the suffix portion of the column names "assay_suffix" that each t stat column corresponds to.
# combs[!(stat1 %in% grep(stat1,pattern="dom|vis",value=T)),asssuff1:="xen"]
# combs[!(stat2 %in% grep(stat2,pattern="dom|vis",value=T)),asssuff2:="xen"]
# 
# combs[stat1 %in% grep(stat1,pattern="visclps",value=T),asssuff1:="visclps"]
# combs[stat2 %in% grep(stat2,pattern="visclps",value=T),asssuff2:="visclps"]
# 
# combs[stat1 %in% grep(stat1,pattern="visdom",value=T),asssuff1:="visdom"]
# combs[stat2 %in% grep(stat2,pattern="visdom",value=T),asssuff2:="visdom"]
# 
# combs[stat1 %in% grep(stat1,pattern="visdom",value=T),asssuff1:="visdom"]
# combs[stat2 %in% grep(stat2,pattern="visdom",value=T),asssuff2:="visdom"]
# 
# combs[stat1 %in% grep(stat1,pattern="xendom",value=T),asssuff1:="xendom"]
# combs[stat2 %in% grep(stat2,pattern="xendom",value=T),asssuff2:="xendom"]
# 
# ## loop through combinations of cell-type/domain pairs and calculate spearman correlation between the t stats for each pair
# i<-1
# for (i in c(1:nrow(combs))){
#     # get the names of the two assay columns being used in this step
#     bycols <- paste0("assay_",combs[i,.(asssuff1,asssuff2)])
#     # calculate the spearman correlation between the two t stat vectors for each unique value in bycols
#     res <- detabs[,cor(get(combs[i,stat1]),get(combs[i,stat2]),method="spearman",use = "pairwise.complete.obs"),by=bycols]
# 
#     # note which t stat columns were used in this step, since several xenium cell type DE analyses have the same assay column (but obv different stat cols).
#     res[,stats:=paste0(combs[i,stat1],"::",combs[i,stat2])]
# 
#     # concatenate
#     if(i==1){corrs <- copy(res)}
#     else{corrs <- rbind(corrs,res,fill=T)}
# }
# # set the correlation column value name
# setnames(corrs,"V1","spearman")
# 
# # drop NAs and 1s (self-correls)
# corrs <- corrs[!(is.na(spearman)|spearman==1)]
# 
# ## tidy up the assay names to correspond to the specific analysis by creating a universal assay 1 and assay 2 column, with the assay suffix changed to the particular DE run
# ## unfortunately i can't think kof a way to easily apply thru this, so we'll do a couple for i loops. not a huge table we're working with anyhow
# ## basically everything except the first copy of the xenium cell type column is our other search space for the majority of rows
# assaycheckcols <- c("assay_xen","assay_xen.1","assay_xendom","assay_visdom","assay_visdom.1","assay_visclps","assay_xendom.1","assay_visclps.1")
# 
# ## initialize the global assay columns
# corrs[,assay1:=""]
# corrs[,assay2:=""]
# 
# i<-1
# for (i in c(1:nrow(corrs))){
#     # get the first nonnull assay column. this isn't pretty, was a lot of guess and check til something worked as desired
#     assaycol1 <- names(unlist(
#         corrs[i,..assaycheckcols])[!is.na(unlist(corrs[i,..assaycheckcols]))])[1]
#     assaycol2 <- names(unlist(
#         corrs[i,..assaycheckcols])[!is.na(unlist(corrs[i,..assaycheckcols]))])[2]
# 
#     set(corrs,i,"assay1",value=corrs[i,get(assaycol1)])
#     set(corrs,i,"assay2",value=corrs[i,get(assaycol2)])
# 
#     ### isolate the identifier from the assay again
#     corrs[i,assay1:=gsub(assay1,pattern="(.*)_.*$",replacement="\\1")]
#     corrs[i,assay2:=gsub(assay2,pattern="(.*)_.*$",replacement="\\1")]
# 
#     ## append the tstat suffix
#     corrs[i,assay1:=paste0(assay1,gsub(corrs[i,stats],pattern="^t(_.*)::.*$",replacement="\\1"))]
#     corrs[i,assay2:=paste0(assay2,gsub(corrs[i,stats],pattern="^.*::t(_.*)$",replacement="\\1"))]
# }
# 
# ## remove self-correlations (some of which have inexplicable > 0.99999999 but < 1 values) and NAs
# corrs <- corrs[!(spearman>0.999999)]
# 
# ### rearrange into assay1, assay2, spearman
# corrsout <- corrs[,.(assay1,assay2,spearman)]
```

```{r}
# ### save
# fwrite(corrsout,"processed-data/08_VMH-ARC cell type sex DE within domains/07-Sex DE correlations between pairs of cell type or domain wise analyses of Xenium, Visium.txt")
```

reprod info
```{r}
sessionInfo()
sessioninfo::session_info()
```
R version 4.4.1 RC (2024-06-06 r86719)
Platform: aarch64-apple-darwin20
Running under: macOS Sonoma 14.5

Matrix products: default
BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib 
LAPACK: /Library/Frameworks/R.framework/Versi
