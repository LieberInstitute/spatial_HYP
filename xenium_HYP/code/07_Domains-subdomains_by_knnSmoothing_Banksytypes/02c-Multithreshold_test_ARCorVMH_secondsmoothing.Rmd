---
title: "02b-Multithreshold_test_ARCorVMH_secondsmoothing"
output: html_document
date: "2024-06-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height = 10,fig.width = 7,include = FALSE)
#### sets tab autocompletion for directories to begin from the directory containing the .Rproj session, instead of the script's directory if different
knitr::opts_knit$set(root.dir = here::here())

library(data.table)
library(spatialLIBD)
library(SpatialFeatureExperiment)
library(sf)
library(gtools)

## rstudio GUI tweaks
require(colorout)
ColorOut()
options("styler.addins_style_transformer" = "biocthis::bioc_style()")
##

## enable forked parallel processing with BiocParallel::multicoreParam, future::, etc. seemed to need this a couple times, but otherwise havent so its here as a preventative measure.
library(parallelly)
options(parallelly.supportsMulticore.disableOn="")
options(parallelly.fork.enable=TRUE)
library(parallel)

# biocparallel wouldn't cooperate with this script, so don't bother--mclapply worked (and was way faster + more memory efficient it looks like)
# library(BiocParallel)
# options(bphost="localhost")
```

### running KNN smoothing 
requires us to binarily identify VMH or ARC first. this was simple when we had cluster assignments with obvious marker genes in the first round smoothing. to run KNN smoothing a second time, however, we must decide on a threshold value from the first round smoothing that maximally enriches the domain-specific cell types (for example, based on spatial patterns or as indexed by levels of marker genes).

recall that the output of the KNN smoothing is a value 0-1, which is the proportion of nearest neighbor cells with an ARC or VMH label. our threshold is thus the minimum proportion of k neighbors that need to be of a domain-alike cell type for a given cell to be considered part of that domain.

we will, consistent with Yi's prior analyses, identify the k=200 nearest neighbors for each VMH cell (defined per threshold iterated through) and k=500 for each ARC cell at a variety of cutoffs from the first round smoothing. we will store the outputs across a variety of smoothing step 1 cutoffs in case we wish to further optimize the clustering (see notes in script 02b in this directory).
if we are dissatisfied with the prior KNN smoothing parameters' results, we will need to test a series of thresholds for defining VMH/ARC from the first round KNN smoothing results.

to assess the relative fidelity of the domain assignments at a given clustering level, will we need to JOINTLY test VMH and ARC at a given cutoff, and then determine the level of key markers' enrichment within each domain. We need to do this jointly, as the VMH and ARC overlap, and thus need to test enrichment of markers comparatively between ARC and VMH to ensure we have identified a boundary that does not shove too many ARC cells into VMH or vice versa.

finally, if the otherwise ideal (max enrichment of markers in desired domain, max depletion of markers in the other) domain boundaries are discontinuous or multiple polygons, we can identify the single large polygonal boundary of all of these cells and define that as the domain, even if there are spotty exclusions. this will be more precise than selecting a threshold that expands the boundaries beyond what is reasonable.

## load the round 2 KNN scores calculated across 10 different thresholds for defining VMH/ARC based on first round KNN scores. also load the SFE for bulk and boundary area DE testing between VMH and ARC
```{r}
vmharc_dualthreshtestres <- readRDS("processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02a-step2knnscoring_of_dual-step1-thresh-series_vmharc_knn_k200_k500.RDS")

hypx <- readRDS("processed-data/05_Banksy_M0lam0_res2_multisamp/01-sfe-in_staggered-coords_genetarg-only_NONlog-norm.RDS")

# pare down the SFE for efficiency: we only need counts for pseudobulk DE (not lognorm or nonlog norm), we can drop a ton of colData columns, and we can drop several columns of qc stuff from rowData
hypx@assays@data@listData$logcounts <- NULL
hypx@assays@data@listData$normcounts <- NULL

colData(hypx) <- colData(hypx)[,c("sample_id","Sample","Barcode","key","BrNum")]

# colnames(rowData(hypx))
rowData(hypx) <- rowData(hypx)[,c(1:3)]

gc(full=T)
```

### for each of 10 round 1 threshold (applied to BOTH arc and vmh) apply the 100 unique combos of round 2 thresholds (ARC/VMH separately), calculate pseudobulk DE of the entire VMH and ARC domains, and define the boundary regions and do likewise. 
```{r}
## get threshold pairs except where a threshold value is 1, since the function will call for > threshold (but 1 is max value). thus "threshold" of 0 is really a minimum of 0.1, threshold 0.1 is min 0.2, etc.

## start with the highest round 1 threshes to isolate the errors occurring in bplapply at higher thresholds quickly
threshes <- seq(0.9,0,-0.1)
threshpairs <- gtools::permutations(n=length(threshes),r=2,v=threshes,repeats.allowed = T)
threshpairs <- as.data.table(threshpairs)
setnames(threshpairs,c("arcT","vmhT"))

## likewise, drop the thresh=1.0 results from the knn smoothing list obj
vmharc_dualthreshtestres <- vmharc_dualthreshtestres[c(1:10)]

### extract domain definitions at threshold sets, test DE between full domains; extract their boundary regions per parameter set and test DE in the VMH@boundary vs ARC@boundary
fullres <- lapply(threshes,FUN=function(t1){
    
    # this gets us the round 2 knn neighbor-cell-type-domain-match-proportion  results performed at a given round 1 threshold:
    t1name <- paste0("tSmooth1_",t1) 
    arc2 <- vmharc_dualthreshtestres[[t1name]]
    vmh2 <- vmharc_dualthreshtestres[[t1name]]
    
    ## get result column names for VMH and ARC smoothing step 2 at the given step 1 thresh
    arc_t1_name <- paste0("arcsmooth2_k500_thresh",t1)
    vmh_t1_name <- paste0("vmhsmooth2_k200_thresh",t1)
    
    ### check the max values for knn round 2 and drop thresholds to be tested where there would be no (or practically no) cells for one or both domaains
    arcmax <- max(arc2[,..arc_t1_name])
    vmhmax <- max(vmh2[,..vmh_t1_name])
    threshpairs2 <- copy(threshpairs[arcmax>arcT & vmhmax>vmhT])
    
    ### trying to work around parallelization bugs so ditch d.t. for this table
    threshpairs2 <- as.data.frame(threshpairs2)
    
    t2reslist <- mclapply(1:nrow(threshpairs2),mc.cores=4,FUN=function(r){
            # make list to hold this thresh pair's bulk and boundary DE test result
            print(paste0("starting t1=",t1,", t2a=",threshpairs2[r,"arcT"],", t2v=",threshpairs2[r,"vmhT"]))
            t2deres <- list()
            
            # get this thresh pair
            athresh2 <- threshpairs2[r,"arcT"]
            vthresh2 <- threshpairs2[r,"vmhT"]
            
            ## define ARC and VMH after smoothing 2 for given cutoffs
            arc2[,isARCsmooth2:="other"]
            arc2[get(arc_t1_name)>athresh2,isARCsmooth2:="ARC"]
            
            vmh2[,isVMHsmooth2:="other"]
            vmh2[get(vmh_t1_name)>vthresh2,isVMHsmooth2:="VMH"]
            
            ## merge these two to deconflict assignments
            arckeepname <- c("rn",arc_t1_name,"xcoord","ycoord","isARCsmooth2")
            vmhkeepname <- c("rn",vmh_t1_name,"isVMHsmooth2")
            vmharc <- merge.data.table(arc2[,..arckeepname],vmh2[,..vmhkeepname],by="rn")
            # for dually-defined cells, assign the domain to that with the greater knn score
            vmharc[isARCsmooth2=="ARC"&isVMHsmooth2=="VMH"&get(arc_t1_name)>get(vmh_t1_name),dualassignedSmooth2:="ARC"]
            vmharc[isARCsmooth2=="ARC"&isVMHsmooth2=="VMH"&get(arc_t1_name)<get(vmh_t1_name),dualassignedSmooth2:="VMH"]
            
            # make the remainder reflective of definitive assignments
            vmharc[isARCsmooth2=="ARC"&isVMHsmooth2=="other",dualassignedSmooth2:="ARC"]
            vmharc[isARCsmooth2=="other"&isVMHsmooth2=="VMH",dualassignedSmooth2:="VMH"]
            vmharc[is.na(dualassignedSmooth2),dualassignedSmooth2:="other"]
            
            if(nrow(vmharc[dualassignedSmooth2=="other"])<=15000|nrow(vmharc[dualassignedSmooth2=="VMH"])<650|nrow(vmharc[dualassignedSmooth2=="ARC"])<650){
                
                t2deres[[1]] <- paste0("fewer than 15k non-VMHARC cells, fewer than 650 VMH cells, and or fewer than 650 ARC cells at this threshold")
                
                names(t2deres)[1] <- paste0("fullDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
                
                return(t2deres)
            }

            # get sample ids from cell ids, tabulate cells per domain per sample
            vmharc[,sample_id:=gsub(rn,pattern="^(.*)_[[:alpha:]]{5,20}-.$",replacement="\\1")]
            domaincellcounts <- vmharc[,.N,by=c("sample_id","dualassignedSmooth2")]
            
            # run full domain pseudobulk DE
            vmharc <- DataFrame(vmharc,row.names=vmharc$rn)
            vmharc <- vmharc[colnames(hypx),]
            
            colLabels(hypx) <- vmharc$dualassignedSmooth2
    
            vmharc_bulkde <- registration_wrapper(hypx,var_registration="label",var_sample_id="sample_id",gene_ensembl="ID",gene_name = "Symbol")
            
            ## extract pairwise de results for VMH-ARC. the "other" cluster is in these results as well (in fact spatialLIBD::registration_wrapper won't run without 3+ clusters) so filter those columns out
            vmharc_bulkde<- as.data.table(vmharc_bulkde[["pairwise"]])
            vabulknames <- c("gene", grep(
                names(vmharc_bulkde),pattern="other|ID",value=T,invert=T))
            vmharc_bulkde <- vmharc_bulkde[,..vabulknames]
            
            ## return a list with the DE results and cell counts
            fulldomoutlist <- list(vmharc_bulkde,domaincellcounts)
            names(fulldomoutlist)[1] <- paste0("bulkDE_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
            names(fulldomoutlist)[2] <- paste0("cellsPerSamp_",names(fulldomoutlist)[1])
            
            t2deres[[1]] <- fulldomoutlist
            names(t2deres)[1] <- paste0("fullDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
    
            
            # get the boundary cells for each sample separately
            ## we already extracted sample_ids above for cell tabulations
            vmharc <- as.data.table(vmharc)
            vmharc.samplist <- split(vmharc,vmharc$sample_id)
            
            vmharc.boundarycells <- lapply(vmharc.samplist,FUN=function(s){
                vmh <- s[dualassignedSmooth2=="VMH"]
                arc <- s[dualassignedSmooth2=="ARC"]
                ## get the points defining the convex hull using sf by running st_union to make a single geometry of all component points, then st_convex_hull to get the hull 
                vmh.sf <- st_as_sf(vmh,coords=c("xcoord","ycoord"))
                vmh.hull <- st_convex_hull(st_union(vmh.sf))
                
                ## arc is not necessarily a CONVEX hull, however. e.g, it's concave where it meets the VMH (in some cases). again, using X86_reg1, calling st_concave_hull with ratio 0.1 (concavity vs convexity parameter, lower = more concavity; 0 just gives a polygon tracing all points sequentially and is not useful) works beautifully, and this is probably the scoop-iest shaped ARC in the dataset. so let's try that for all samples
                arc.sf <- st_as_sf(arc,coords=c("xcoord","ycoord"))
                arc.hull <- st_concave_hull(st_union(arc.sf),ratio=0.1)
                
                ## add a buffer zone the domain hull polygons. our coordinates span about 10000 unitless values in the x and y planes for each tissue section, so a buffer adding about 4% to the hull should be good. we can approximate this by calculating the median of the pairwise distances between points defining the domain hull
                vmh.buffdist <- median(dist(st_coordinates(vmh.hull)))
                vmh.buffhull <- st_buffer(vmh.hull,dist=0.04*vmh.buffdist)
                
                arc.buffdist <- median(dist(st_coordinates(arc.hull)))
                arc.buffhull <- st_buffer(arc.hull,dist=0.04*arc.buffdist)
                
                ## then fucking finally, get the polygon defining where these buffered hulls that overlap, which should thus encompass the vicinity of where a "true" VMH and ARC boundary lies. extract the portions of the overlapping buffers that were assigned ARC or VMH domains by the original smoothing. these are what we want to run DE on next.
                vmharc.buffintsec <- st_intersection(vmh.buffhull,arc.buffhull)
                
                buffintsec.invmh <- st_intersection(vmharc.buffintsec,vmh.hull)
                buffintsec.inarc <- st_intersection(vmharc.buffintsec,arc.hull)
    
        ## really, truly finally, get the cells that fall within this VMH-arc boundary polygon in each respective domain.
                vmh.inboundary <- st_within(vmh.sf,buffintsec.invmh,sparse = F)
                vmh.boundarycells <- as.data.frame(vmh)[vmh.inboundary,"rn"]
                
                arc.inboundary <- st_within(arc.sf,buffintsec.inarc,sparse=F)
                arc.boundarycells <- as.data.frame(arc)[arc.inboundary,"rn"]
                
                bndcl <- list(vmh.boundarycells,arc.boundarycells)
                return(bndcl)
            })
            
            ### extract the boundary cell ids for all the samples and label them in the SFE for DE testing ###
            vmh.boundaryids <- unlist(lapply(vmharc.boundarycells,FUN=function(x){unlist(x[[1]])}))
            arc.boundaryids <- unlist(lapply(vmharc.boundarycells,FUN=function(x){unlist(x[[2]])}))
            
            ## no point continuing if no boundary cells
            if(length(vmh.boundaryids)<150 | length(arc.boundaryids)<150){
                t2deres[[2]] <- paste0("under 150 boundary cells for VMH or ARC found for t1=",t1,", t2a=",athresh2,", t2v=",vthresh2)
                names(t2deres)[2] <- paste0("boundaryDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
            }
            else{
                ## to test DE, we need a third cell type in order for registration_wrapper to run, which is way easier than any other option for pseudobulk DE, so grab some and label them as other
                ## subset the SFE with some random cells in addition
                othercells <- sample(colnames(hypx)[!colnames(hypx) %in% c(vmh.boundaryids,arc.boundaryids)],size=15000,replace = F)
                
                hypx.bdry <- hypx[,c(vmh.boundaryids, arc.boundaryids, othercells)]
                
                ## make domain labels of VMH(boundary), ARC(boundary), or other (throwaway cells)
                boundarylabs <- as.data.table(colnames(hypx.bdry))
                setnames(boundarylabs,1,"rn")
                
                boundarylabs[rn %in% othercells,domain:="other"]
                boundarylabs[rn %in% vmh.boundaryids,domain:="VMHboundary"]
                boundarylabs[rn %in% arc.boundaryids,domain:="ARCboundary"]
                
                boundarylabs <- DataFrame(boundarylabs,row.names=boundarylabs$rn)
                boundarylabs <- boundarylabs[colnames(hypx.bdry),]
                
                colLabels(hypx.bdry) <- boundarylabs$domain
                
                ## get number of cells per boundary domain per sample
                boundarycellcounts <- as.data.table(colData(hypx.bdry))[,.N,by=c("sample_id","label")]
                
                ## run de with registration_wrapper --> grab pairwise results between portions of the boundary region
                boundaryde <- spatialLIBD::registration_wrapper(hypx.bdry,var_registration = "label",var_sample_id = "sample_id",gene_ensembl = "ID",gene_name = "Symbol")
                
                boundaryde <- as.data.table(boundaryde[["pairwise"]])
                
                keepnames <- grep(
                    names(boundaryde),pattern="other|ensembl",value=T,invert=T)
                boundaryde <- boundaryde[,..keepnames]
                
                bdryoutlist <- list(boundaryde,boundarycellcounts)
                names(bdryoutlist)[1] <- paste0("bdryDE_thr1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
                names(bdryoutlist)[2] <- paste0("bdryCellsPerSamp_",names(bdryoutlist)[1])
                
                t2deres[[2]] <- bdryoutlist
                names(t2deres)[2] <- paste0("boundaryDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)

            }
        return(t2deres)
    })
})
names(fullres) <- paste0("thresh1_",threshes)

## save the results
## for some reason thresh1 of 0.8 just didn't return any results for any t2 combination, even though thresh1 of 0.9 did. so we'll have to revisit that later
saveRDS(fullres,"processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02c-fullDom_4pctMediDiamBdryDom_DE_by_threshpairs.RDS")
```

t1 0.8 is the buggy one
```{r}
t1 <- 0.8
# this gets us the round 2 knn neighbor-cell-type-domain-match-proportion  results performed at a given round 1 threshold:
t1name <- paste0("tSmooth1_",t1) 
arc2 <- vmharc_dualthreshtestres[[t1name]]
vmh2 <- vmharc_dualthreshtestres[[t1name]]

## get result column names for VMH and ARC smoothing step 2 at the given step 1 thresh
arc_t1_name <- paste0("arcsmooth2_k500_thresh",t1)
vmh_t1_name <- paste0("vmhsmooth2_k200_thresh",t1)

### check the max values for knn round 2 and drop thresholds to be tested where there would be no (or practically no) cells for one or both domaains
arcmax <- max(arc2[,..arc_t1_name])
vmhmax <- max(vmh2[,..vmh_t1_name])
threshpairs2 <- copy(threshpairs[arcmax>arcT & vmhmax>vmhT])

## arc 0 vmh 0.1 causes a full bomb-icon rstudio crash at the end of the boundary DE. remove this pair and repeat
threshpairs2 <- threshpairs2[!(arcT<0.01&vmhT>0.09&vmhT<0.11)]
## next one to cause a bomb-out was arc 0.1 vmh 0.1, so remove that one too
threshpairs2 <- threshpairs2[!(arcT>0.09&arcT<0.11&vmhT>0.09&vmhT<0.11)]
## and then arc 0.2 vmh 0.1...seeing a pattern?
threshpairs2 <- threshpairs2[!(vmhT>0.09&vmhT<0.11)]
### trying to work around parallelization bugs so ditch d.t. for this table
threshpairs2 <- as.data.frame(threshpairs2)


reslist8 <- list()
j<-1
for (j in c(1:nrow(threshpairs2))){
    r <- j
    print(paste0("starting t1=",t1,", t2a=",threshpairs2[r,"arcT"],", t2v=",threshpairs2[r,"vmhT"]))
    t2deres <- list()
    
    # get this thresh pair
    athresh2 <- threshpairs2[r,"arcT"]
    vthresh2 <- threshpairs2[r,"vmhT"]
    
    ## define ARC and VMH after smoothing 2 for given cutoffs
    arc2[,isARCsmooth2:="other"]
    arc2[get(arc_t1_name)>athresh2,isARCsmooth2:="ARC"]
    
    vmh2[,isVMHsmooth2:="other"]
    vmh2[get(vmh_t1_name)>vthresh2,isVMHsmooth2:="VMH"]
    
    ## merge these two to deconflict assignments
    arckeepname <- c("rn",arc_t1_name,"xcoord","ycoord","isARCsmooth2")
    vmhkeepname <- c("rn",vmh_t1_name,"isVMHsmooth2")
    vmharc <- merge.data.table(arc2[,..arckeepname],vmh2[,..vmhkeepname],by="rn")
    # for dually-defined cells, assign the domain to that with the greater knn score
    vmharc[isARCsmooth2=="ARC"&isVMHsmooth2=="VMH"&get(arc_t1_name)>get(vmh_t1_name),dualassignedSmooth2:="ARC"]
    vmharc[isARCsmooth2=="ARC"&isVMHsmooth2=="VMH"&get(arc_t1_name)<get(vmh_t1_name),dualassignedSmooth2:="VMH"]
    
    # make the remainder reflective of definitive assignments
    vmharc[isARCsmooth2=="ARC"&isVMHsmooth2=="other",dualassignedSmooth2:="ARC"]
    vmharc[isARCsmooth2=="other"&isVMHsmooth2=="VMH",dualassignedSmooth2:="VMH"]
    vmharc[is.na(dualassignedSmooth2),dualassignedSmooth2:="other"]
    
    if(nrow(vmharc[dualassignedSmooth2=="other"])<=15000|nrow(vmharc[dualassignedSmooth2=="VMH"])<650|nrow(vmharc[dualassignedSmooth2=="ARC"])<650){
        
        t2deres[[1]] <- paste0("fewer than 15k non-VMHARC cells, fewer than 650 VMH cells, and or fewer than 650 ARC cells at this threshold")
        
        names(t2deres)[1] <- paste0("fullDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
    
        reslist8[[j]] <- t2deres
        next(j)
    }

    # get sample ids from cell ids, tabulate cells per domain per sample
    vmharc[,sample_id:=gsub(rn,pattern="^(.*)_[[:alpha:]]{5,20}-.$",replacement="\\1")]
    domaincellcounts <- vmharc[,.N,by=c("sample_id","dualassignedSmooth2")]
    
    # run full domain pseudobulk DE
    vmharc <- DataFrame(vmharc,row.names=vmharc$rn)
    vmharc <- vmharc[colnames(hypx),]
    
    colLabels(hypx) <- vmharc$dualassignedSmooth2

    vmharc_bulkde <- registration_wrapper(hypx,var_registration="label",var_sample_id="sample_id",gene_ensembl="ID",gene_name = "Symbol")
    
    ## extract pairwise de results for VMH-ARC. the "other" cluster is in these results as well (in fact spatialLIBD::registration_wrapper won't run without 3+ clusters) so filter those columns out
    vmharc_bulkde<- as.data.table(vmharc_bulkde[["pairwise"]])
    vabulknames <- c("gene", grep(
        names(vmharc_bulkde),pattern="other|ID",value=T,invert=T))
    vmharc_bulkde <- vmharc_bulkde[,..vabulknames]
    
    ## return a list with the DE results and cell counts
    fulldomoutlist <- list(vmharc_bulkde,domaincellcounts)
    names(fulldomoutlist)[1] <- paste0("bulkDE_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
    names(fulldomoutlist)[2] <- paste0("cellsPerSamp_",names(fulldomoutlist)[1])
    
    t2deres[[1]] <- fulldomoutlist
    names(t2deres)[1] <- paste0("fullDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)

    
    # get the boundary cells for each sample separately
    ## we already extracted sample_ids above for cell tabulations
    vmharc <- as.data.table(vmharc)
    vmharc.samplist <- split(vmharc,vmharc$sample_id)
    
    vmharc.boundarycells <- lapply(vmharc.samplist,FUN=function(s){
        vmh <- s[dualassignedSmooth2=="VMH"]
        arc <- s[dualassignedSmooth2=="ARC"]
        ## get the points defining the convex hull using sf by running st_union to make a single geometry of all component points, then st_convex_hull to get the hull 
        vmh.sf <- st_as_sf(vmh,coords=c("xcoord","ycoord"))
        vmh.hull <- st_convex_hull(st_union(vmh.sf))
        
        ## arc is not necessarily a CONVEX hull, however. e.g, it's concave where it meets the VMH (in some cases). again, using X86_reg1, calling st_concave_hull with ratio 0.1 (concavity vs convexity parameter, lower = more concavity; 0 just gives a polygon tracing all points sequentially and is not useful) works beautifully, and this is probably the scoop-iest shaped ARC in the dataset. so let's try that for all samples
        arc.sf <- st_as_sf(arc,coords=c("xcoord","ycoord"))
        arc.hull <- st_concave_hull(st_union(arc.sf),ratio=0.1)
        
        ## add a buffer zone the domain hull polygons. our coordinates span about 10000 unitless values in the x and y planes for each tissue section, so a buffer adding about 4% to the hull should be good. we can approximate this by calculating the median of the pairwise distances between points defining the domain hull
        vmh.buffdist <- median(dist(st_coordinates(vmh.hull)))
        vmh.buffhull <- st_buffer(vmh.hull,dist=0.04*vmh.buffdist)
        
        arc.buffdist <- median(dist(st_coordinates(arc.hull)))
        arc.buffhull <- st_buffer(arc.hull,dist=0.04*arc.buffdist)
        
        ## then fucking finally, get the polygon defining where these buffered hulls that overlap, which should thus encompass the vicinity of where a "true" VMH and ARC boundary lies. extract the portions of the overlapping buffers that were assigned ARC or VMH domains by the original smoothing. these are what we want to run DE on next.
        vmharc.buffintsec <- st_intersection(vmh.buffhull,arc.buffhull)
        
        buffintsec.invmh <- st_intersection(vmharc.buffintsec,vmh.hull)
        buffintsec.inarc <- st_intersection(vmharc.buffintsec,arc.hull)

## really, truly finally, get the cells that fall within this VMH-arc boundary polygon in each respective domain.
        vmh.inboundary <- st_within(vmh.sf,buffintsec.invmh,sparse = F)
        vmh.boundarycells <- as.data.frame(vmh)[vmh.inboundary,"rn"]
        
        arc.inboundary <- st_within(arc.sf,buffintsec.inarc,sparse=F)
        arc.boundarycells <- as.data.frame(arc)[arc.inboundary,"rn"]
        
        bndcl <- list(vmh.boundarycells,arc.boundarycells)
        return(bndcl)
    })
    
    ### extract the boundary cell ids for all the samples and label them in the SFE for DE testing ###
    vmh.boundaryids <- unlist(lapply(vmharc.boundarycells,FUN=function(x){unlist(x[[1]])}))
    arc.boundaryids <- unlist(lapply(vmharc.boundarycells,FUN=function(x){unlist(x[[2]])}))
    
    ## no point continuing if no boundary cells
    if(length(vmh.boundaryids)<150 | length(arc.boundaryids)<150){
        t2deres[[2]] <- paste0("under 150 boundary cells for VMH or ARC found for t1=",t1,", t2a=",athresh2,", t2v=",vthresh2)
        names(t2deres)[2] <- paste0("boundaryDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
        reslist8[[j]] <- t2deres
        next(j)
    }
    else{
        ## to test DE, we need a third cell type in order for registration_wrapper to run, which is way easier than any other option for pseudobulk DE, so grab some and label them as other
        ## subset the SFE with some random cells in addition
        othercells <- sample(colnames(hypx)[!colnames(hypx) %in% c(vmh.boundaryids,arc.boundaryids)],size=15000,replace = F)
        
        hypx.bdry <- hypx[,c(vmh.boundaryids, arc.boundaryids, othercells)]
        
        ## make domain labels of VMH(boundary), ARC(boundary), or other (throwaway cells)
        boundarylabs <- as.data.table(colnames(hypx.bdry))
        setnames(boundarylabs,1,"rn")
        
        boundarylabs[rn %in% othercells,domain:="other"]
        boundarylabs[rn %in% vmh.boundaryids,domain:="VMHboundary"]
        boundarylabs[rn %in% arc.boundaryids,domain:="ARCboundary"]
        
        boundarylabs <- DataFrame(boundarylabs,row.names=boundarylabs$rn)
        boundarylabs <- boundarylabs[colnames(hypx.bdry),]
        
        colLabels(hypx.bdry) <- boundarylabs$domain
        
        ## get number of cells per boundary domain per sample
        boundarycellcounts <- as.data.table(colData(hypx.bdry))[,.N,by=c("sample_id","label")]
        
        ## run de with registration_wrapper --> grab pairwise results between portions of the boundary region
        boundaryde <- spatialLIBD::registration_wrapper(hypx.bdry,var_registration = "label",var_sample_id = "sample_id",gene_ensembl = "ID",gene_name = "Symbol")
        
        boundaryde <- as.data.table(boundaryde[["pairwise"]])
        
        keepnames <- grep(
            names(boundaryde),pattern="other|ensembl",value=T,invert=T)
        boundaryde <- boundaryde[,..keepnames]
        
        bdryoutlist <- list(boundaryde,boundarycellcounts)
        names(bdryoutlist)[1] <- paste0("bdryDE_thr1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
        names(bdryoutlist)[2] <- paste0("bdryCellsPerSamp_",names(bdryoutlist)[1])
        
        t2deres[[2]] <- bdryoutlist
        names(t2deres)[2] <- paste0("boundaryDom_thresh1_",t1,"_thr2ARC_",athresh2,"_thr2VMH_",vthresh2)
        
        reslist8[[j]] <- t2deres
        next(j)
    }

}

## update the results in the thresh1 0.8 slot of the output RDS obj saved above
fullres <- readRDS("processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02b-fullDom_4pctMediDiamBdryDom_DE_by_threshpairs.RDS")

fullres[["thresh1_0.8"]] <- reslist8
saveRDS(fullres,"processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02b-fullDom_4pctMediDiamBdryDom_DE_by_threshpairs.RDS")

## 
rm(list=ls())
gc(full=T)
```


### reproducibility info
```{r}
sessionInfo()
sessioninfo::session_info()
```
R version 4.4.1 RC (2024-06-06 r86719)
Platform: aarch64-apple-darwin20
Running under: macOS Sonoma 14.5

Matrix products: default
BLAS:   /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib 
LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

time zone: America/Chicago
tzcode source: internal

attached base packages:
[1] parallel  stats4    stats     graphics  grDevices utils     datasets 
[8] methods   base     

other attached packages:
 [1] parallelly_1.37.1              colorout_1.3-0.2              
 [3] gtools_3.9.5                   sf_1.0-16                     
 [5] SpatialFeatureExperiment_1.6.1 spatialLIBD_1.16.2            
 [7] SpatialExperiment_1.14.0       SingleCellExperiment_1.26.0   
 [9] SummarizedExperiment_1.34.0    Biobase_2.64.0                
[11] GenomicRanges_1.56.1           GenomeInfoDb_1.40.1           
[13] IRanges_2.38.0                 S4Vectors_0.42.0              
[15] BiocGenerics_0.50.0            MatrixGenerics_1.16.0         
[17] matrixStats_1.3.0              data.table_1.15.4             
[19] rlang_1.1.4                   

loaded via a namespace (and not attached):
  [1] later_1.3.2               BiocIO_1.14.0            
  [3] bitops_1.0-7              filelock_1.0.3           
  [5] fields_15.2               R.oo_1.26.0              
  [7] tibble_3.2.1              XML_3.99-0.17            
  [9] lifecycle_1.0.4           edgeR_4.2.0              
 [11] doParallel_1.0.17         rprojroot_2.0.4          
 [13] lattice_0.22-6            magrittr_2.0.3           
 [15] limma_3.60.3              plotly_4.10.4            
 [17] sass_0.4.9                rmarkdown_2.27           
 [19] jquerylib_0.1.4           yaml_2.3.8               
 [21] httpuv_1.6.15             spam_2.10-0              
 [23] sp_2.1-4                  sessioninfo_1.2.2        
 [25] cowplot_1.1.3             DBI_1.2.3                
 [27] RColorBrewer_1.1-3        golem_0.4.1              
 [29] maps_3.4.2                abind_1.4-5              
 [31] zlibbioc_1.50.0           R.utils_2.12.3           
 [33] purrr_1.0.2               RCurl_1.98-1.14          
 [35] rappdirs_0.3.3            GenomeInfoDbData_1.2.12  
 [37] ggrepel_0.9.5             irlba_2.3.5.1            
 [39] terra_1.7-78              units_0.8-5              
 [41] dqrng_0.4.1               DelayedMatrixStats_1.26.0
 [43] codetools_0.2-20          DropletUtils_1.24.0      
 [45] DelayedArray_0.30.1       DT_0.33                  
 [47] scuttle_1.14.0            tidyselect_1.2.1         
 [49] UCSC.utils_1.0.0          ScaledMatrix_1.12.0      
 [51] viridis_0.6.5             shinyWidgets_0.8.6       
 [53] BiocFileCache_2.12.0      GenomicAlignments_1.40.0 
 [55] jsonlite_1.8.8            BiocNeighbors_1.22.0     
 [57] e1071_1.7-14              scater_1.32.0            
 [59] iterators_1.0.14          foreach_1.5.2            
 [61] tools_4.4.1               Rcpp_1.0.12              
 [63] glue_1.7.0                gridExtra_2.3            
 [65] SparseArray_1.4.8         xfun_0.45                
 [67] here_1.0.1                EBImage_4.46.0           
 [69] dplyr_1.1.4               HDF5Array_1.32.0         
 [71] BiocManager_1.30.23       fastmap_1.2.0            
 [73] boot_1.3-30               rhdf5filters_1.16.0      
 [75] fansi_1.0.6               spData_2.3.1             
 [77] digest_0.6.36             rsvd_1.0.5               
 [79] R6_2.5.1                  mime_0.12                
 [81] wk_0.9.1                  colorspace_2.1-0         
 [83] jpeg_0.1-10               RSQLite_2.3.7            
 [85] R.methodsS3_1.8.2         config_0.3.2             
 [87] utf8_1.2.4                tidyr_1.3.1              
 [89] generics_0.1.3            class_7.3-22             
 [91] rtracklayer_1.64.0        httr_1.4.7               
 [93] htmlwidgets_1.6.4         S4Arrays_1.4.1           
 [95] spdep_1.3-5               pkgconfig_2.0.3          
 [97] gtable_0.3.5              blob_1.2.4               
 [99] XVector_0.44.0            htmltools_0.5.8.1        
[101] dotCall64_1.1-1           fftwtools_0.9-11         
[103] scales_1.3.0              png_0.1-8                
[105] attempt_0.3.1             knitr_1.47               
[107] rstudioapi_0.16.0         rjson_0.2.21             
[109] curl_5.2.1                proxy_0.4-27             
[111] rhdf5_2.48.0              cachem_1.1.0             
[113] KernSmooth_2.23-24        BiocVersion_3.19.1       
[115] vipor_0.4.7               AnnotationDbi_1.66.0     
[117] s2_1.1.6                  restfulr_0.0.15          
[119] pillar_1.9.0              grid_4.4.1               
[121] vctrs_0.6.5               promises_1.3.0           
[123] BiocSingular_1.20.0       dbplyr_2.5.0             
[125] beachmat_2.20.0           sfheaders_0.4.4          
[127] xtable_1.8-4              beeswarm_0.4.0           
[129] paletteer_1.6.0           evaluate_0.24.0          
[131] zeallot_0.1.0             magick_2.8.3             
[133] cli_3.6.3                 locfit_1.5-9.10          
[135] compiler_4.4.1            Rsamtools_2.20.0         
[137] crayon_1.5.3              classInt_0.4-10          
[139] rematch2_2.1.2            ggbeeswarm_0.7.2         
[141] deldir_2.0-4              viridisLite_0.4.2        
[143] BiocParallel_1.38.0       munsell_0.5.1            
[145] Biostrings_2.72.1         tiff_0.1-12              
[147] lazyeval_0.2.2            Matrix_1.7-0             
[149] ExperimentHub_2.12.0      benchmarkme_1.0.8        
[151] sparseMatrixStats_1.16.0  bit64_4.0.5              
[153] Rhdf5lib_1.26.0           ggplot2_3.5.1            
[155] KEGGREST_1.44.1           statmod_1.5.0            
[157] shiny_1.8.1.1             AnnotationHub_3.12.0     
[159] memoise_2.0.1             bslib_0.7.0              
[161] benchmarkmeData_1.0.4     bit_4.0.5                
> sessioninfo::session_info()
─ Session info ────────────────────────────────────────────────────────────────
 setting  value
 version  R version 4.4.1 RC (2024-06-06 r86719)
 os       macOS Sonoma 14.5
 system   aarch64, darwin20
 ui       RStudio
 language (EN)
 collate  en_US.UTF-8
 ctype    en_US.UTF-8
 tz       America/Chicago
 date     2024-06-30
 rstudio  2024.07.0-daily+219 Cranberry Hibiscus (desktop)
 pandoc   3.1.11 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/aarch64/ (via rmarkdown)

─ Packages ────────────────────────────────────────────────────────────────────
 ! package                  * version   date (UTC) lib source
   abind                      1.4-5     2016-07-21 [1] CRAN (R 4.4.0)
   AnnotationDbi              1.66.0    2024-05-01 [1] Bioconductor 3.19 (R 4.4.0)
   AnnotationHub              3.12.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   attempt                    0.3.1     2020-05-03 [1] CRAN (R 4.4.0)
   beachmat                   2.20.0    2024-05-06 [1] Bioconductor 3.19 (R 4.4.0)
   beeswarm                   0.4.0     2021-06-01 [1] CRAN (R 4.4.0)
   benchmarkme                1.0.8     2022-06-12 [1] CRAN (R 4.4.0)
   benchmarkmeData            1.0.4     2020-04-23 [1] CRAN (R 4.4.0)
   Biobase                  * 2.64.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   BiocFileCache              2.12.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   BiocGenerics             * 0.50.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   BiocIO                     1.14.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   BiocManager                1.30.23   2024-05-04 [1] CRAN (R 4.4.0)
   BiocNeighbors              1.22.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   BiocParallel               1.38.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   BiocSingular               1.20.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   BiocVersion                3.19.1    2024-04-22 [1] Bioconductor 3.19 (R 4.4.0)
   Biostrings                 2.72.1    2024-06-02 [1] Bioconductor 3.19 (R 4.4.0)
   bit                        4.0.5     2022-11-15 [1] CRAN (R 4.4.0)
   bit64                      4.0.5     2020-08-30 [1] CRAN (R 4.4.0)
   bitops                     1.0-7     2021-04-24 [1] CRAN (R 4.4.0)
   blob                       1.2.4     2023-03-17 [1] CRAN (R 4.4.0)
   boot                       1.3-30    2024-02-26 [1] CRAN (R 4.4.1)
   bslib                      0.7.0     2024-03-29 [1] CRAN (R 4.4.0)
   cachem                     1.1.0     2024-05-16 [1] CRAN (R 4.4.0)
   class                      7.3-22    2023-05-03 [1] CRAN (R 4.4.1)
   classInt                   0.4-10    2023-09-05 [1] CRAN (R 4.4.0)
 P cli                        3.6.3     2024-06-21 [2] CRAN (R 4.4.0)
   codetools                  0.2-20    2024-03-31 [1] CRAN (R 4.4.1)
   colorout                 * 1.3-0.2   2024-05-01 [1] Github (jalvesaq/colorout@c6113a2)
   colorspace                 2.1-0     2023-01-23 [1] CRAN (R 4.4.0)
   config                     0.3.2     2023-08-30 [1] CRAN (R 4.4.0)
   cowplot                    1.1.3     2024-01-22 [1] CRAN (R 4.4.0)
   crayon                     1.5.3     2024-06-20 [1] CRAN (R 4.4.0)
   curl                       5.2.1     2024-03-01 [1] CRAN (R 4.4.0)
   data.table               * 1.15.4    2024-03-30 [2] CRAN (R 4.4.0)
   DBI                        1.2.3     2024-06-02 [1] CRAN (R 4.4.0)
   dbplyr                     2.5.0     2024-03-19 [1] CRAN (R 4.4.0)
   DelayedArray               0.30.1    2024-05-07 [1] Bioconductor 3.19 (R 4.4.0)
   DelayedMatrixStats         1.26.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   deldir                     2.0-4     2024-02-28 [1] CRAN (R 4.4.0)
   digest                     0.6.36    2024-06-23 [1] CRAN (R 4.4.0)
   doParallel                 1.0.17    2022-02-07 [1] CRAN (R 4.4.0)
   dotCall64                  1.1-1     2023-11-28 [1] CRAN (R 4.4.0)
   dplyr                      1.1.4     2023-11-17 [1] CRAN (R 4.4.0)
   dqrng                      0.4.1     2024-05-28 [1] CRAN (R 4.4.0)
   DropletUtils               1.24.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   DT                         0.33      2024-04-04 [1] CRAN (R 4.4.0)
   e1071                      1.7-14    2023-12-06 [1] CRAN (R 4.4.0)
   EBImage                    4.46.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   edgeR                      4.2.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   evaluate                   0.24.0    2024-06-10 [1] CRAN (R 4.4.0)
   ExperimentHub              2.12.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   fansi                      1.0.6     2023-12-08 [1] CRAN (R 4.4.0)
   fastmap                    1.2.0     2024-05-15 [1] CRAN (R 4.4.0)
   fftwtools                  0.9-11    2021-03-01 [1] CRAN (R 4.4.0)
   fields                     15.2      2023-08-17 [1] CRAN (R 4.4.0)
   filelock                   1.0.3     2023-12-11 [1] CRAN (R 4.4.0)
   foreach                    1.5.2     2022-02-02 [1] CRAN (R 4.4.0)
   generics                   0.1.3     2022-07-05 [1] CRAN (R 4.4.0)
   GenomeInfoDb             * 1.40.1    2024-05-24 [1] Bioconductor 3.19 (R 4.4.0)
   GenomeInfoDbData           1.2.12    2024-05-01 [1] Bioconductor
   GenomicAlignments          1.40.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   GenomicRanges            * 1.56.1    2024-06-12 [1] Bioconductor 3.19 (R 4.4.1)
   ggbeeswarm                 0.7.2     2023-04-29 [1] CRAN (R 4.4.0)
   ggplot2                    3.5.1     2024-04-23 [1] CRAN (R 4.4.0)
   ggrepel                    0.9.5     2024-01-10 [1] CRAN (R 4.4.0)
   glue                       1.7.0     2024-01-09 [1] CRAN (R 4.4.0)
   golem                      0.4.1     2023-06-05 [1] CRAN (R 4.4.0)
   gridExtra                  2.3       2017-09-09 [1] CRAN (R 4.4.0)
   gtable                     0.3.5     2024-04-22 [1] CRAN (R 4.4.0)
   gtools                   * 3.9.5     2023-11-20 [1] CRAN (R 4.4.0)
   HDF5Array                  1.32.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   here                       1.0.1     2020-12-13 [1] CRAN (R 4.4.0)
   htmltools                  0.5.8.1   2024-04-04 [1] CRAN (R 4.4.0)
   htmlwidgets                1.6.4     2023-12-06 [1] CRAN (R 4.4.0)
   httpuv                     1.6.15    2024-03-26 [1] CRAN (R 4.4.0)
   httr                       1.4.7     2023-08-15 [1] CRAN (R 4.4.0)
   IRanges                  * 2.38.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   irlba                      2.3.5.1   2022-10-03 [1] CRAN (R 4.4.0)
   iterators                  1.0.14    2022-02-05 [1] CRAN (R 4.4.0)
   jpeg                       0.1-10    2022-11-29 [1] CRAN (R 4.4.0)
   jquerylib                  0.1.4     2021-04-26 [1] CRAN (R 4.4.0)
   jsonlite                   1.8.8     2023-12-04 [1] CRAN (R 4.4.0)
   KEGGREST                   1.44.1    2024-06-19 [1] Bioconductor 3.19 (R 4.4.0)
   KernSmooth                 2.23-24   2024-05-17 [1] CRAN (R 4.4.1)
   knitr                      1.47      2024-05-29 [1] CRAN (R 4.4.0)
   later                      1.3.2     2023-12-06 [1] CRAN (R 4.4.0)
   lattice                    0.22-6    2024-03-20 [1] CRAN (R 4.4.1)
   lazyeval                   0.2.2     2019-03-15 [1] CRAN (R 4.4.0)
   lifecycle                  1.0.4     2023-11-07 [1] CRAN (R 4.4.0)
   limma                      3.60.3    2024-06-16 [1] Bioconductor 3.19 (R 4.4.0)
   locfit                     1.5-9.10  2024-06-24 [1] CRAN (R 4.4.0)
   magick                     2.8.3     2024-02-18 [1] CRAN (R 4.4.0)
   magrittr                   2.0.3     2022-03-30 [1] CRAN (R 4.4.0)
   maps                       3.4.2     2023-12-15 [1] CRAN (R 4.4.0)
   Matrix                     1.7-0     2024-04-26 [1] CRAN (R 4.4.1)
   MatrixGenerics           * 1.16.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   matrixStats              * 1.3.0     2024-04-11 [1] CRAN (R 4.4.0)
   memoise                    2.0.1     2021-11-26 [1] CRAN (R 4.4.0)
   mime                       0.12      2021-09-28 [1] CRAN (R 4.4.0)
   munsell                    0.5.1     2024-04-01 [1] CRAN (R 4.4.0)
   paletteer                  1.6.0     2024-01-21 [1] CRAN (R 4.4.0)
   parallelly               * 1.37.1    2024-02-29 [1] CRAN (R 4.4.0)
   pillar                     1.9.0     2023-03-22 [1] CRAN (R 4.4.0)
   pkgconfig                  2.0.3     2019-09-22 [1] CRAN (R 4.4.0)
   plotly                     4.10.4    2024-01-13 [1] CRAN (R 4.4.0)
   png                        0.1-8     2022-11-29 [1] CRAN (R 4.4.0)
   promises                   1.3.0     2024-04-05 [1] CRAN (R 4.4.0)
   proxy                      0.4-27    2022-06-09 [1] CRAN (R 4.4.0)
   purrr                      1.0.2     2023-08-10 [1] CRAN (R 4.4.0)
   R.methodsS3                1.8.2     2022-06-13 [1] CRAN (R 4.4.0)
   R.oo                       1.26.0    2024-01-24 [1] CRAN (R 4.4.0)
   R.utils                    2.12.3    2023-11-18 [1] CRAN (R 4.4.0)
   R6                         2.5.1     2021-08-19 [1] CRAN (R 4.4.0)
   rappdirs                   0.3.3     2021-01-31 [1] CRAN (R 4.4.0)
   RColorBrewer               1.1-3     2022-04-03 [1] CRAN (R 4.4.0)
   Rcpp                       1.0.12    2024-01-09 [1] CRAN (R 4.4.0)
   RCurl                      1.98-1.14 2024-01-09 [1] CRAN (R 4.4.0)
   rematch2                   2.1.2     2020-05-01 [1] CRAN (R 4.4.0)
   restfulr                   0.0.15    2022-06-16 [1] CRAN (R 4.4.0)
   rhdf5                      2.48.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   rhdf5filters               1.16.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   Rhdf5lib                   1.26.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   rjson                      0.2.21    2022-01-09 [1] CRAN (R 4.4.0)
 P rlang                    * 1.1.4     2024-06-04 [2] CRAN (R 4.4.1)
   rmarkdown                  2.27      2024-05-17 [1] CRAN (R 4.4.0)
   rprojroot                  2.0.4     2023-11-05 [1] CRAN (R 4.4.0)
   Rsamtools                  2.20.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   RSQLite                    2.3.7     2024-05-27 [1] CRAN (R 4.4.0)
   rstudioapi                 0.16.0    2024-03-24 [1] CRAN (R 4.4.0)
   rsvd                       1.0.5     2021-04-16 [1] CRAN (R 4.4.0)
   rtracklayer                1.64.0    2024-05-06 [1] Bioconductor 3.19 (R 4.4.0)
   s2                         1.1.6     2023-12-19 [1] CRAN (R 4.4.0)
   S4Arrays                   1.4.1     2024-05-20 [1] Bioconductor 3.19 (R 4.4.0)
   S4Vectors                * 0.42.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   sass                       0.4.9     2024-03-15 [1] CRAN (R 4.4.0)
   ScaledMatrix               1.12.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   scales                     1.3.0     2023-11-28 [1] CRAN (R 4.4.0)
   scater                     1.32.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   scuttle                    1.14.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   sessioninfo                1.2.2     2021-12-06 [1] CRAN (R 4.4.0)
   sf                       * 1.0-16    2024-03-24 [1] CRAN (R 4.4.0)
   sfheaders                  0.4.4     2024-01-17 [1] CRAN (R 4.4.0)
   shiny                      1.8.1.1   2024-04-02 [1] CRAN (R 4.4.0)
   shinyWidgets               0.8.6     2024-04-24 [1] CRAN (R 4.4.0)
   SingleCellExperiment     * 1.26.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   sp                         2.1-4     2024-04-30 [1] CRAN (R 4.4.0)
   spam                       2.10-0    2023-10-23 [1] CRAN (R 4.4.0)
   SparseArray                1.4.8     2024-05-30 [1] Bioconductor 3.19 (R 4.4.0)
   sparseMatrixStats          1.16.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   SpatialExperiment        * 1.14.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   SpatialFeatureExperiment * 1.6.1     2024-05-15 [1] Bioconductor 3.19 (R 4.4.0)
   spatialLIBD              * 1.16.2    2024-05-28 [1] Bioconductor 3.19 (R 4.4.0)
   spData                     2.3.1     2024-05-31 [1] CRAN (R 4.4.0)
   spdep                      1.3-5     2024-06-10 [1] CRAN (R 4.4.0)
   statmod                    1.5.0     2023-01-06 [1] CRAN (R 4.4.0)
   SummarizedExperiment     * 1.34.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   terra                      1.7-78    2024-05-22 [1] CRAN (R 4.4.0)
   tibble                     3.2.1     2023-03-20 [1] CRAN (R 4.4.0)
   tidyr                      1.3.1     2024-01-24 [1] CRAN (R 4.4.0)
   tidyselect                 1.2.1     2024-03-11 [1] CRAN (R 4.4.0)
   tiff                       0.1-12    2023-11-28 [1] CRAN (R 4.4.0)
   UCSC.utils                 1.0.0     2024-05-06 [1] Bioconductor 3.19 (R 4.4.0)
   units                      0.8-5     2023-11-28 [1] CRAN (R 4.4.0)
   utf8                       1.2.4     2023-10-22 [1] CRAN (R 4.4.0)
   vctrs                      0.6.5     2023-12-01 [1] CRAN (R 4.4.0)
   vipor                      0.4.7     2023-12-18 [1] CRAN (R 4.4.0)
   viridis                    0.6.5     2024-01-29 [1] CRAN (R 4.4.0)
   viridisLite                0.4.2     2023-05-02 [1] CRAN (R 4.4.0)
   wk                         0.9.1     2023-11-29 [1] CRAN (R 4.4.0)
   xfun                       0.45      2024-06-16 [1] CRAN (R 4.4.0)
   XML                        3.99-0.17 2024-06-25 [1] CRAN (R 4.4.0)
   xtable                     1.8-4     2019-04-21 [1] CRAN (R 4.4.0)
   XVector                    0.44.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)
   yaml                       2.3.8     2023-12-11 [1] CRAN (R 4.4.0)
   zeallot                    0.1.0     2018-01-28 [1] CRAN (R 4.4.0)
   zlibbioc                   1.50.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.0)

 [1] /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library
 [2] /Users/bmulvey/Library/R/arm64/4.4/library

 P ── Loaded and on-disk path mismatch.

───────────────────────────────────────────────────────────────────────────────
