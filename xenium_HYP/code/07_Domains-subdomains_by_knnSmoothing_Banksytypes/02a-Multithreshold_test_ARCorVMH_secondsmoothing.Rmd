---
title: "02a-Multithreshold_test_ARCorVMH_secondsmoothing"
output: html_document
date: "2024-06-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.height = 10,fig.width = 7,include = FALSE)
#### sets tab autocompletion for directories to begin from the directory containing the .Rproj session, instead of the script's directory if different
knitr::opts_knit$set(root.dir = here::here())

library(data.table)
library(FastKNN)
library(caTools)
library(FNN)

## rstudio GUI tweaks
require(colorout)
ColorOut()
options("styler.addins_style_transformer" = "biocthis::bioc_style()")
##

## enable forked parallel processing with BiocParallel::multicoreParam, future::, etc. seemed to need this a couple times, but otherwise havent so its here as a preventative measure.
library(parallelly)
options(parallelly.supportsMulticore.disableOn="")
options(parallelly.fork.enable=TRUE)
library(BiocParallel)
options(bphost="localhost")
```

the following code stems from the following two R scripts: 
• ../../code/0_untidied_Xenium_code_preJune2024/xenium_2runs_together/withQC/cellLevel/lambda0_updatedDomain_May14_2024/step3_post_smooth_vmh_arc/step2_knn/postSmooth_ARC_knn_k500.R
• ../../code/0_untidied_Xenium_code_preJune2024/xenium_2runs_together/withQC/cellLevel/lambda0_updatedDomain_May14_2024/step3_post_smooth_vmh_arc/step2_knn/postSmooth_VMH_knn_k200.R


##### start by reading in the first round KNN results (coordinates, sample and cell ids, and knn predictions). 
```{r}
vmhknn1 <- fread("processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/01a-step1smoothing_VMH_knn-k10.txt")

arcknn1 <- fread("processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/01b-step1smoothing_arc_knn-k50.txt")

## remove the cluster-based isvmh/isarc labels, since we will be redefining those here based on knn prediction values
vmhknn1[,isVMH:=NULL]
arcknn1[,isARC:=NULL]
```

### running KNN smoothing 
requires us to binarily identify VMH or ARC first. this was simple when we had cluster assignments with obvious marker genes in the first round smoothing. to run KNN smoothing a second time, however, we must decide on a threshold value from the first round smoothing that maximally enriches the domain-specific cell types (as indexed by levels of marker genes).

to do this, we now need to test a series of thresholds for defining VMH/ARC from the first round KNN smoothing results. recall that the output of the KNN smoothing (previously and from the following code) is/will be a value 0-1, which is the proportion of nearest neighbor cells with an ARC or VMH label. our threshold is thus the minimum proportion of k neighbors that need to be of a domain-alike cell type for a given cell to be considered part of that domain.

to assess the relative fidelity of the domain assignments at a given clustering level, will we need to JOINTLY test VMH and ARC at a given cutoff, and then determine the level of key markers' enrichment within each domain. We need to do this jointly, as the VMH and ARC overlap, and thus need to test enrichment of markers comparatively between ARC and VMH to ensure we have identified a boundary that does not shove too many ARC cells into VMH or vice versa.

finally, if the otherwise ideal (max enrichment of markers in desired domain, max depletion of markers in the other) domain boundaries are discontinuous or multiple polygons, we can identify the single large polygonal boundary of all of these cells and define that as the domain, even if there are spotty exclusions. this will be more precise than selecting a threshold that expands the boundaries beyond what is reasonable.

we will, consistent with Yi's prior analyses, identify the k=200 nearest neighbors for each VMH cell (defined per threshold iterated through) and k=500 for each ARC cell at a variety of cutoffs from the first round smoothing, and test their pseudobulk enrichments in markers of each domain.

```{r}
threshes <- seq(0.1,1,0.1)

# divy up samplewise for sample-level smoothing, remove concatenated tables to free a bit of RAM
vmhsamps <- split(vmhknn1,vmhknn1$sample_id)
arcsamps <- split(arcknn1,arcknn1$sample_id)
rm(arcknn1,vmhknn1)
gc(full=T)

## iterate over sampelwise smoothing with k=200 (VMH) or 500 (ARC) for each smoothing1 threshold for defining preliminary VMH/ARC 
vmharc_dualthreshtestres <- lapply(threshes,FUN=function(t){
    # for each sample at this threshold, define the VMH and ARC cells based on their round 1 KNN smoothing score
    vmhsamps <- lapply(vmhsamps,function(samp){
        samp[,isVMH:=ifelse(vmhpred.smooth1.k10>t,yes=1,no=0)]
    })
    arcsamps <- lapply(arcsamps,function(samp){
        samp[,isARC:=ifelse(arcpred.smooth1.k50>t,yes=1,no=0)]
    })
    
    # within each sample, get the k (200 vmh, 500 ARC) nearest neighbors of each cell. we only care about the first item in get.knn's list output, the indices of neighboring cells
    vmh_knnres <- bplapply(vmhsamps,BPPARAM=MulticoreParam(10), FUN=function(v){
        vknnres <- FNN::get.knn(v[,.(xcoord,ycoord)],k = 200)
        
         # get the row indices of each cells k neighbors in list format
        vneighbs <- apply(vknnres$nn.index,MARGIN=1,FUN=list)
         # goofily, this is returns each entry as a list within a list (e.g., [[1]][[1]], [[2]][[1]], etc.). so fix that:
        vneighbs <- lapply(vneighbs,FUN=unlist)
        
        # make the list names the cell identifiers as a failsafe against reordering; we will use the list entry names to retrieve the neighbor indices when calculating means below
        names(vneighbs) <- v$rn
        # remoove intermediate objs
        rm(vknnres)
        
        # make a column name to go into the vmh table corresponding to this threshold (we'll collapse them altogether after)
        vthreshname <- paste0("vmhsmooth2_k200_thresh",t)
        # make the column and fill it with means of isVMH for a cell's k neighbors 
        v[,newcol:=
          apply(.SD, MARGIN = 1, FUN=function(x){
              mean(v[vneighbs[[x]],isVMH])
          })
          ,.SDcols = "rn"]
        
        setnames(v,"newcol",vthreshname)
        return(v)
    })
    gc(full=T)
    # same procedure for ARC
    
    arc_knnres <- bplapply(arcsamps,BPPARAM=MulticoreParam(10), FUN=function(a){
        aknnres <- FNN::get.knn(a[,.(xcoord,ycoord)],k = 500)
        
         # get the row indices of each cells k neighbors in list format
        aneighbs <- apply(aknnres$nn.index,MARGIN=1,FUN=list)
        # goofily, this is returns each entry as a list within a list (e.g., [[1]][[1]], [[2]][[1]], etc.). so fix that:
        aneighbs <- lapply(aneighbs,FUN=unlist)
        
        # make the list names the cell identifiers as a failsafe against reordering; we will use the list entry names to retrieve the neighbor indices when calculating means below
        names(aneighbs) <- a$rn
        # remoove intermediate obj
        rm(aknnres)
        
        # make a column name to go into the arc table corresponding to this threshold (we'll collapse them altogether after)
        athreshname <- paste0("arcsmooth2_k500_thresh",t)
        # make the column and fill it with means of isarc for a cell's k neighbors 
        a[,newcol:=
          apply(.SD, MARGIN = 1, FUN=function(x){
              mean(a[aneighbs[[x]],isARC])
          })
      ,.SDcols = "rn"]
        
        setnames(a,"newcol",athreshname)
        return(a)
    })
    gc(full=T)
    
    outlist <- list(vmh_knnres,arc_knnres)
    names(outlist) <- paste0(c("VMHk200_smooth2_tSmooth1_","ARCk500_smooth2_tSmooth1_"),t)
    return(outlist)
})

names(vmharc_dualthreshtestres) <- paste0("tSmooth1_",threshes)
```

### Now, collapse each second-level list entry 
into one table of vmh and arc results from smoothing 2 at a threshold. These 2 results are contained within the first-level lists from the above output, and we will now have a list of 13 tables.
Then, merge each of thoseeeeee by cell_id and threshold score to get one unified table of all cell ids, their coordinates (identical in every table output), and scores for all thresholds tested.
```{r}
vmharc_dualthreshtestres <- bplapply(vmharc_dualthreshtestres, BPPARAM=MulticoreParam(10), FUN=function(x){
    vmh <- rbindlist(x[[1]])
    arc <- rbindlist(x[[2]])
    # subset to key names (rn in both for merging, x and y coords from one, vmhsmooth2 result column or arcsmooth2 column)
    keepvnames <- c("rn","xcoord","ycoord",grep(names(vmh),pattern="smooth2",value=T))
    keepanames <- c("rn",grep(names(arc),pattern="smooth2",value=T))
    vmh <- vmh[,..keepvnames]
    arc <- arc[,..keepanames]
    # merge by cell id
    out <- merge(vmh,arc,by="rn")
    return(out)
})
## save this output
### save output from this step
saveRDS(vmharc_dualthreshtestres,"processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02a-step2smoothing_of_dual-step1-thresh-series_vmharc_knn_k200_k500.RDS")


### now merge each of these tables together for a unified table of one cell id, one x-y pair, and the VMH and ARC scores for each of the 10 smoothing round 1 thresholds tested
i<-1
for (i in c(1:length(vmharc_dualthreshtestres))){
    if(i==1){
        allthreshres <- vmharc_dualthreshtestres[[i]]
    }
    else{
        tmp <- vmharc_dualthreshtestres[[i]]
        keepnames <- c("rn",grep(names(tmp),pattern="smooth2",value=T))
        tmp <- tmp[,..keepnames]
        allthreshres <- merge.data.table(allthreshres,tmp,by="rn")
        rm(tmp,keepnames)
    }
}
rm(i)

fwrite(allthreshres,"processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02b-step2smoothing_of_dual-step1-thresh-series_vmharc_knn_k200_k500_collapsed.txt",sep='\t',quote=F)

### clean up 
```

### clear the workspace except the list-per-round1-thresh object and load spatialLIBD and the SFE for marker analyses
```{r}
rm(vmhsamps,arcsamps,allthreshres,threshes)
gc(full=T)

library(spatialLIBD)
library(SpatialFeatureExperiment)
hypx <- readRDS("processed-data/05_Banksy_M0lam0_res2_multisamp/01-sfe-in_staggered-coords_genetarg-only_NONlog-norm.RDS")
```

### first test marker enrichment using the VMH/ARC thresholds from Yi's code, and check for how frequently cells pass the respective thresholds for both layers. these cutoffs were
ARC (stage 1, k50): >0.1
ARC (stage 2, k500): >0.3
VMH (stage 1, k10): >0.2
VMH (stage 2, k200): >0.2

```{r}
arc.yi <- vmharc_dualthreshtestres[["tSmooth1_0.1"]]
arc.yi[,isARCsmooth2:=ifelse(arcsmooth2_k500_thresh0.1>0.3, yes="ARC_yi_2stage",no="other")]

vmh.yi <- vmharc_dualthreshtestres[["tSmooth1_0.2"]]
vmh.yi[,isVMHsmooth2:=ifelse(vmhsmooth2_k200_thresh0.2>0.2, yes="VMH_yi_2stage",no="other")]

### how many cells passed each thresholds doing this?
### more importantly, how many cells pass BOTH thresholds doing this, which as far as i can tell was not accounted for in those analyses?
vmharc.yi <- merge.data.table(arc.yi[,.(rn,arcsmooth2_k500_thresh0.1,xcoord,ycoord,isARCsmooth2)],vmh.yi[,.(rn,vmhsmooth2_k200_thresh0.2,isVMHsmooth2)],by="rn")

vmharc.yi[,.N,by=c("isARCsmooth2","isVMHsmooth2")]
## ~148k are ARC, ~110k are VMH; 599851 are other
## and another ~10k overlap (~7% of ARC, ~9% of VMH cells are not actually a specific domain)
```

## for dually-defined cells, assign the domain to that with the greater knn score (which may well not be the best way to do this but is the simplest for testing enrichments on this parameter set).
```{r}
vmharc.yi[isARCsmooth2=="ARC_yi_2stage"&isVMHsmooth2=="VMH_yi_2stage",dualassignedSmooth2:=ifelse(arcsmooth2_k500_thresh0.1>vmhsmooth2_k200_thresh0.2, yes="ARC_yi_2stage",no="VMH_yi_2stage")]

## transfer the other domain assignments to the dualassigned column
vmharc.yi[isARCsmooth2=="ARC_yi_2stage"&isVMHsmooth2=="other",dualassignedSmooth2:=isARCsmooth2]
vmharc.yi[isVMHsmooth2=="VMH_yi_2stage"&isARCsmooth2=="other",dualassignedSmooth2:=isVMHsmooth2]
vmharc.yi[isVMHsmooth2=="other"&isARCsmooth2=="other",dualassignedSmooth2:="other"]

# ### sanity check: make sure the "other" domain is the same size as before, which shouldn't have changed here
# vmharc.yi[,.N,by="dualassignedSmooth2"]
# other 599851 -- same as before. ok.
## also note here that of 11990 passing both final domain definition thresholds, 4562 were assigned to VMH and 7158 were assigned to ARC using the greater knn score.

## clean up
rm(arc.yi,vmh.yi,vmharc_dualthreshtestres)
```
#### other 599851 -- same as before. ok.
#### also note here that of 11990 passing both final domain definition thresholds, 4562 were assigned to VMH and 7158 were assigned to ARC using the greater knn score.

### now, append the assignments using our de-conflicted results of Yi's parameters to the SFE and test head-to-head, FULL domain DE of VMH vs. ARC
```{r} 
vmharc.yi <- DataFrame(vmharc.yi,row.names = vmharc.yi$rn)
vmharc.yi <- vmharc.yi[colnames(hypx),]
colLabels(hypx) <- vmharc.yi$dualassignedSmooth2

## test enrichment
yivmharc.de <- spatialLIBD::registration_wrapper(hypx,var_registration = "label",var_sample_id = "sample_id",gene_ensembl = "ID",gene_name = "Symbol")

## extract the VMH-ARC pairwise enrichments from the output list
yivmharc.de <- as.data.table(yivmharc.de[["pairwise"]])
keepnames <- grep(names(yivmharc.de),pattern="VMH",value=T)
keepnames <- c("gene",grep(keepnames,pattern="ARC",value=T))

yivmharc.de <- yivmharc.de[,..keepnames]
## label previously ascertained VMH markers and ARC markers and subset to these
yivmharc.de[gene %in% c("POMC","GHRH","ESR1","TAC3","AGRP","NPY","GAD1","GAD2"),knownmarkerof:="ARC"]
yivmharc.de[gene %in% c("NRGN","ADCYAP1","SLC17A6","NR5A1","LAMP5","FEZF1","ANKRD34B"),knownmarkerof:="VMH"]

yivmharc.de <- yivmharc.de[knownmarkerof %in% c("ARC","VMH")]
## notably, POMC (which is definitely pan-ARC specific, confirmed by RNAscope as well as visium) is rel. weakly enriched (logFC = 2.9) compared to some other ARC subtype markers e.g. GHRH.

## save these DE stats for comparison to other results depending on the plots.
fwrite(yivmharc.de,"processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02a-VMHARC_domains_yi-thresholds_pseudobulkDE.txt",sep='\t',quote=F)

## clean up
rm(yivmharc.de)
gc()
```

### we also want to more precisely test the boundary area of VMH and ARC to test for expected marker DE in the domains where the overlap may be blurry. let's see if we can extract that boundary computationally.

#### github copilot explains that functions in the package `sf` can be used to extend the boundary of two polygonal areas by first creating a buffer zone around each, then finding the overlap OF those buffer zones. let's try that here.
```{r}
library(sf)
## make a samplewise list of VMH, ARC domains and define their convex hulls at yi's cutoffs
## we'll need to extract the sample ids from the cell identifiers first
vmharc.yi[,sample_id:=gsub(rn,pattern="^(.*)_[[:alpha:]]{5,20}-.$",replacement="\\1")]
# sanity check
stopifnot(length(unique(vmharc.yi$sample_id))==length(unique(hypx$sample_id)))
# split
vmharc.yi.samplist <- split(vmharc.yi,vmharc.yi$sample_id)

## divy each sample into VMH and ARC subtables for defining their respective polygons; extract convex hulls, convert to sf objects and create additional buffer zones, then find their overlaps (which define the approx ARC-VMH boundary region) and extract the VMH/ARC domain cells in that boundary region for downstream enrichment testing 
vmharc.yi.boundarycells <- bplapply(vmharc.yi.samplist,BPPARAM=MulticoreParam(10),FUN=function(s){
    vmh <- s[dualassignedSmooth2=="VMH_yi_2stage"]
    arc <- s[dualassignedSmooth2=="ARC_yi_2stage"]

    ## get the points defining the convex hull using sf by running st_union to make a single geometry of all component points, then st_convex_hull to get the hull
    vmh.sf <- st_as_sf(vmh,coords=c("xcoord","ycoord"))
    vmh.hull <- st_convex_hull(st_union(vmh.sf))
    
    ## arc is not necessarily a CONVEX hull, however. e.g, it's concave where it meets the VMH (in some cases). again, using X86_reg1, calling st_concave_hull with ratio 0.1 (concavity vs convexity parameter, lower = more concavity; 0 just gives a polygon tracing all points sequentially and is not useful) works beautifully, and this is probably the scoop-iest shaped ARC in the dataset. so let's try that for all samples
    arc.sf <- st_as_sf(arc,coords=c("xcoord","ycoord"))
    arc.hull <- st_concave_hull(st_union(arc.sf),ratio=0.1)

    ## add a buffer zone the domain hull polygons. our coordinates span about 10000 unitless values in the x and y planes for each tissue section, so a buffer adding about 4% to the hull should be good. we can approximate this by calculating the median of the pairwise distances between points defining the domain hull
    
    vmh.buffdist <- median(dist(st_coordinates(vmh.hull)))
    vmh.buffhull <- st_buffer(vmh.hull,dist=0.04*vmh.buffdist)

    arc.buffdist <- median(dist(st_coordinates(arc.hull)))
    arc.buffhull <- st_buffer(arc.hull,dist=0.04*arc.buffdist)

    ## then fucking finally, get the polygon defining where these buffered hulls that overlap, which should thus encompass the vicinity of where a "true" VMH and ARC boundary lies. extract the portions of the overlapping buffers that were assigned ARC or VMH domains by the original smoothing. these are what we want to run DE on next. 
    vmharc.buffintsec <- st_intersection(vmh.buffhull,arc.buffhull)

    buffintsec.invmh <- st_intersection(vmharc.buffintsec,vmh.hull)
    buffintsec.inarc <- st_intersection(vmharc.buffintsec,arc.hull)

    ## really, truly finally, get the cells that fall within this VMH-arc boundary polygon in each respective domain.
    vmh.inboundary <- st_within(vmh.sf,buffintsec.invmh,sparse = F)
    vmh.boundarycells <- as.data.frame(vmh)[vmh.inboundary,"rn"]
    
    arc.inboundary <- st_within(arc.sf,buffintsec.inarc,sparse=F)
    arc.boundarycells <- as.data.frame(arc)[arc.inboundary,"rn"]
    return(list(vmhboundcells=vmh.boundarycells,arcboundcells=arc.boundarycells))
})

# clean up
rm(vmharc.yi.samplist)
gc(full=T)
```

### extract the cells from the above result, subset the SFE to those cells, label them according to which domain they're assigned within the boundary region, and test DE between VMH-boundary and ARC-boundary.
```{r}
vmh.boundaryids <- unlist(lapply(vmharc.yi.boundarycells,FUN=function(x){unlist(x[[1]])}))
arc.boundaryids <- unlist(lapply(vmharc.yi.boundarycells,FUN=function(x){unlist(x[[2]])}))

## to test DE, we need a third cell type in order for registration_wrapper to run, which is way easier than any other option for pseudobulk DE, so just grab a few hundred exatra cells from the SFE and label them as "other" for this test--we're not considering results involving those cells anyhow.
## subset the SFE with some random cells in addition
othercells <- sample(colnames(hypx),size=15000,replace = F)

hypx.boundary <- hypx[,unique(c(vmh.boundaryids,arc.boundaryids,othercells))]

## make domain labels of VMH(boundary), ARC(boundary), or other (throwaway cells)
boundarylabs <- as.data.table(colnames(hypx.boundary))
setnames(boundarylabs,1,"rn")

boundarylabs[rn %in% othercells,domain:="other"]
boundarylabs[rn %in% vmh.boundaryids,domain:="VMHboundary"]
boundarylabs[rn %in% arc.boundaryids,domain:="ARCboundary"]

boundarylabs <- DataFrame(boundarylabs,row.names=boundarylabs$rn)
boundarylabs <- boundarylabs[colnames(hypx.boundary),]

colLabels(hypx.boundary) <- boundarylabs$domain

## run de with registration_wrapper --> grab pairwise results between portions of the boundary region
boundaryde <- spatialLIBD::registration_wrapper(hypx.boundary,var_registration = "label",var_sample_id = "sample_id",gene_ensembl = "ID",gene_name = "Symbol")
## clean up 
rm(hypx.boundary,boundarylabs,othercells,arc.boundaryids,vmh.boundaryids)

boundaryde <- as.data.table(boundaryde[["pairwise"]])
keepnames <- c("gene",grep(names(boundaryde),pattern="boundary",value=T))
keepnames <- grep(keepnames,pattern="other",value=T,invert=T)
boundaryde <- boundaryde[,..keepnames]

## save result
fwrite(boundaryde,"processed-data/07_Domains-subdomains_by_knnSmoothing_Banksytypes/02a-VMHARC_domains_yi-threshes_boundaryarea-VMH-ARC-DE.txt",sep='\t',quote=F)
```

#### LEFT OFF HERE ####

### given the relatively weak enrichment of e.g., POMC, in boundary-domain ARC vs. VMH (not FDR significant for the boundary cells), and all markers having expected direction but lower logFC (< 2 in their expected domain for the boundary) than for full domain comparisons (ranging logFCs 2.5-5), let's test a series of additional thresholds for the second-stage smoothing cutoff.

### Final domains will (eventually) be defined
by selecting thresholds of the SECOND round smoothing scores as cutoffs for defining the VMH domain or the ARC domain. Since these thresholds may not be equal (we assumed so above only for the sake of computational efficiency), we'll iterate through pairs of VMH/ARC KNNround2 score thresholds, then test marker enrichments of VMH vs. ARC defined using each threshold pair. The optimal threshold pair will maximize both VMH and ARC marker enrichment in their respective domains relative to the other, due to the VMH and ARC directly abutting one another. (Thus, a poorer definition will allow for more "true ARC" expression to be bundled into VMH and vice versa). 


```{r}
thresh <- seq(0.1,1,0.1)
# get all combinations of these in both directions (e.g., 0.1,0.2 and 0.2,0.1--adirectional pairs (e.g., only having a 0.1, 0.2 or 0.2,0.1 entry once are a separate function in gtools--gtools::combinations()))
# including self-combinations (e.g., 0.1,0.1; repeats.allowed=T below)
threshpairs <- as.data.table(as.data.frame(gtools::permutations(v=thresh,n=length(thresh),r=2,repeats.allowed = T)))

setnames(threshpairs,c("vmh_smooth2_thresh","arc_smooth2_thresh"))
vmharc_dualthreshtest2_res <- lapply(vmharc_dualthreshtestres,FUN=function(d){
    # for each threshold pair, define the VMH and ARC cells based on their round 2 KNN smoothing score
    vmh <- d[,.(rn,xcoord,ycoord,grep(names(d),pattern="vmhsmooth2",value=T))]
    arc <- d[,.(rn,xcoord,ycoord,grep(names(d),pattern="arcsmooth2",value=T))]
    
    # for each threshold pair, define the VMH and ARC cells based on their round 2 KNN smoothing score
    vmh[,isVMH:=ifelse(vmh$vmh_smooth2_thresh>t,yes=1,no=0)]
    arc[,isARC:=ifelse(arc$arc_smooth2_thresh>t,yes=1,no=0)]
    
    # within each sample, get the k (200 vmh, 500 ARC) nearest neighbors of each cell. we only care about the first item in get.knn's list output, the indices of neighboring cells
    vmh_knnres <- FNN::get.knn(vmh[,.(xcoord,ycoord)],k = 200)
    arc_knnres <- FNN::get.knn(arc[,.(xcoord,ycoord)],k = 500)
    
    # get the row indices of each cells k neighbors in list format
    vneighbs <- apply(vmh_knnres$nn.index,MARGIN=1,FUN=list)
    aneighbs <- apply(arc_knnres$nn.index,MARGIN=1,FUN=list)
    
    # goofily, this is returns each entry as a list within a list (e.g., [[1]][[1]], [[2]][[1]], etc.). so fix that:
    vneighbs <- lapply(vneighbs,FUN=unlist)
    aneighbs <- lapply(aneighbs,FUN=unlist)
    
    # make the list names the cell identifiers as a failsafe against reordering; we will use the list entry names to retrieve the neighbor indices when calculating means below
    names(vneighbs) <- vmh$rn
    names(aneighbs) <- arc$rn
    
    # make a column name to go into the vmh table corresponding to this threshold (we'll collapse them altogether after)
    vthreshname <- paste0("vmhsmooth2_k200_thresh_",t)
    athreshname <- paste0("arcsmooith2_k500_thresh_",t)
})
```
