---
title: "01-HVGs"
author: "Bernie Mulvey"
date: "2023-05-23"
output: html_document
---

```{r setup, include=FALSE}
#### sets tab autocompletion for directories to begin from the directory containing the .Rproj session, instead of the script's directory if different
knitr::opts_knit$set(root.dir = here::here())

library(data.table)
library(SpatialExperiment)
library(ggspavis)
library(scater) # addPerCellQC
library(BiocParallel)
library(scran)

theme_set(theme_bw()+theme(axis.text.x = element_text(size = 14), axis.title.x = element_text(size = 16), axis.text.y = element_text(size = 14), axis.title.y = element_text(size =16), plot.title = element_text(size = 20,hjust=0.5), strip.text = element_text(size=18), legend.text = element_text(size=10), legend.title = element_text(size=11,hjust=0.5)))
```

### PART 1: Without batch, etc correction ###

### scran - variable genes (HVG), spatially agnostic
### OSTA verbatim: "If the biologically meaningful spatial information in this dataset mainly reflects spatial distributions of major cell types, then relying on HVGs for downstream analyses may be sufficient. But if there are additional important spatial features in the dataset, then it may be more meaningful to define spatially variable genes."
### We won't know with the hyp samples til we know. So let's start unsupervised.
```{r}
# ordinarily, we exclude mitochondrial genes as not of interest. but the LC spatial preprint highlighted that LC neurons had very high mitochondrial reads, so what the hey, we'll keep them in here and just grab extra top HVGs to account for the fact that the 13 mito genes might take up some of the list.

hyp2 <- readRDS("data/processing/hyp_umi600_gene450_chrm35_lognorm.RDS")
# first, we model gene-level mean-variance relationships
hyp2.vars <- modelGeneVar(hyp2)
hyp2.vars.fit <- metadata(hyp2.vars)

# # plot in base R:
# plot(splc2.vars.fit$mean, splc2.vars.fit$var, 
#      xlab = "mean of log-expression", ylab = "variance of log-expression")
# curve(splc2.vars.fit$trend(x), col = "blue", add = TRUE, lwd = 2)
# dev.off()
# plot in ggplot2
hyp2.vars.dt <- as.data.table(hyp2.vars.fit$var,keep.rownames=T)
hyp2.means.dt <- as.data.table(hyp2.vars.fit$mean,keep.rownames=T)
stopifnot(sum(hyp2.means.dt$V1==hyp2.vars.dt$V1)==nrow(hyp2.means.dt))
setnames(hyp2.vars.dt,2,"var_log_xpr")
setnames(hyp2.means.dt,2,"mean_log_xpr")
hyp2.mnvar.pltdat <- merge(hyp2.means.dt,hyp2.vars.dt,by="V1")

rm(hyp2.vars.dt,hyp2.means.dt)
# ggplot(hyp2.mnvar.pltdat,aes(x=mean_log_xpr,y=var_log_xpr))+
#   geom_point()+
# geom_line(data=environment(hyp2.vars.fit$trend),aes(x=x,y=y),inherit.aes = F)

# ^ "`data` must be a <data.frame>, or an object coercible by `fortify()`, not an environment."

# pdf("plots/01-feature_selection/mean-var-relation_umi600_gene450_mito35_NOharmony.pdf",height=6,width=6)
ggplot(hyp2.mnvar.pltdat, aes(x = mean_log_xpr, y = var_log_xpr)) +
    geom_point() +
    geom_function(fun=hyp2.vars.fit$trend,col="blue")
dev.off()
rm(hyp2.mnvar.pltdat)
```

#### HVGs continued: pull out the top p % of variable genes (returns a vector of identifiers,no stats etc)
```{r}
hyp2.hvg10 <- scran::getTopHVGs(hyp2.vars,prop = 0.1)
hyp2.hvg20 <- scran::getTopHVGs(hyp2.vars,prop=0.2)
# saveRDS(hyp2.hvg10,"analysis/data/01-feature_selection/top10pct_HVGs_NOharmony.RDS")
# saveRDS(hyp2.hvg20,"analysis/data/01-feature_selection/top20pct_HVGs_NOharmony.RDS")
```


### Spatially variable genes--nnSVG
```{r}
# X = covariates
# default n_neighbors = 10, but can also be bumped up to 15

# first, filter the data with nnSVG's built in filtering function. Per Lukas Weber, subsequent nnSVG may get slowed down by trying to handle very low-expressed genes.


# let's also keep mitochondrial genes for now.
hyp3 <- nnSVG::filter_genes(hyp2,filter_genes_ncounts = 2,filter_genes_pcspots = 0.5, filter_mito = F)
# even w/ these parmeters, we've cut the data down to about 10k genes from 36k!
```


# now the workhorse function nnSVG, which can use parallel processing through BiocParallel. Set up the preferred (i.e., compatible) param. the parallelization is within nnsvg, so no need to match cpu # to sample #
```{r}
sbp <- SnowParam(10,type="FORK",fallback=F)

# SUPER CRITICAL IMPORTANT NOTES: 
# 1. RECALCULATE LOG COUNTS AFTER FILTERING ^
# 2.nnSVG works ONE SAMPLE (one capture area) at a time. So need to wrap this in a loop. 
# 3. as such, perform filtering PER SAMPLE. 
# filter_genes_ncounts (N) and filter_genes_pcspots (S) work together: genes will be filtered to those with at least N counts in at least S% of spots.  filter_genes_pcspots expects a %age as 0-100, NOT a fraction.
# since most spots are pretty diverse and high-depth (but the cell type diversity is also unknown), we'll come down a bit from the respective N default to 2 counts in at least S=0.5% of spots (default).

# With vignette as a guide...:
caps <- unique(colData(hyp2)$sample_id)
res_list2 <- as.list(rep(NA, length(caps)))
names(res_list2) <- caps

i<-1
for (i in c(1:length(caps))){
  cap <- caps[i]
  hyp2.samp <- hyp2[,colData(hyp2)$sample_id==cap]
  # dim(hyp2.samp)
  hyp2.samp <- filter_genes(hyp2.samp,filter_genes_ncounts = 2,filter_genes_pcspots = 0.25,filter_mito = F)
  #recalculate logcounts
  hyp2.samp <- computeLibraryFactors(hyp2.samp)
  hyp2.samp <- logNormCounts(hyp2.samp)
  # main call -- defaults to logcounts but shown for posterity; X if using covariates; n_neighbors defaults to 10, slower but potentially more granular with higher values eg 15, order = don't touch unless you have < 70 spots total; n_threads or BPPARAM for parallelization
  res_list2[[i]] <- nnSVG(hyp2.samp,assay_name = "logcounts",BPPARAM = sbp)
  rm(hyp2.samp,cap)
  gc(full=T)
}
# computer slept on me and stopped the run mid-sample #5. but whatever this is for demonstrative purposes so that's sufficient.
# res_list <- res_list[1:4]
# saveRDS(nnsvg_res_list,"nnSVG_results_4of8samples_050423.RDS")
rm(i,caps,sbp)
gc(full=T)
```


### Let's take a look at one set of nnSVG results (which are 12 columns appended to rowData including spatial covariance, pval/padj, and rank)
```{r}
nnsvg_res_list <- readRDS("nnSVG_results_4of8samples_050423.RDS")
rD <- as.data.table(rowData(nnsvg_res_list[[1]]),keep.rownames=T)
```
### To determine experiment-wide nnSVG-derived SVGs, average the ranks from each sample in our results list.

```{r}
i<-1
for (i in c(1:sum(unique(colData(splc2)$sample_id)%in%names(nnsvg_res_list)))){
  if(i==1){
  nnsvg_ranks <- as.data.table(rowData(nnsvg_res_list[[i]]),keep.rownames=T)
  nnsvg_ranks <- nnsvg_ranks[,.(rn,gene_name,rank)]
  setnames(nnsvg_ranks,3,names(nnsvg_res_list)[i])
  }
  else{
  tmp <- as.data.table(rowData(nnsvg_res_list[[i]]),keep.rownames=T)
  tmp <- tmp[,.(rn,gene_name,rank)]
  setnames(tmp,3,names(nnsvg_res_list)[i])
  nnsvg_ranks <- merge.data.table(nnsvg_ranks,tmp,by=c("rn","gene_name"))
  rm(tmp)
  }
}
rm(i)

nnsvg_ranks[,meanrank:=rowMeans(.SD),.SDcols=c(3:6)]
```

There are 1310 HVGs; let's compare what's unique and shared between the 1310 HVGs and top 1310 SVGs by mean rank.
```{r}
setorder(nnsvg_ranks,meanrank)
sum(splc2.hvgs %in% nnsvg_ranks$rn[1:1310])
# 402 shared
# let's plot how many of the SVGs are in the 1310 HVGs over a step series of 25 genes
olap.plt <- as.data.frame(matrix(nrow=1300/25,ncol=2))
olap.plt[,1] <- seq(from=26,to=1301,by=25)
i <- 1
for (i in c(1:nrow(olap.plt))){
  olap.plt[i,2] <- sum(splc2.hvgs %in% nnsvg_ranks$rn[c(1:olap.plt[i,1])])/(olap.plt[i,1])
}
rm(i)

colnames(olap.plt) <- c("Top n SVGs","% in 1310 HVGs")

ggplot(olap.plt,aes(x=`Top n SVGs`,y=`% in 1310 HVGs`))+
  geom_col()
dev.off()

## lets make sets of the top 1310 SVGs and the top 1310 SVGs + all 1310 HVGs as a second vector so we can visualize the different sets in clusters downstream. also the equivalent length of unique hvgs + top 1310 svgs in top svgs alone. 
splc2.svgs <- nnsvg_ranks[1:1310,rn]
splc2.hsvgs <- unique(c(splc2.hvgs,splc2.svgs))
splc2.2218svgs <- nnsvg_ranks[1:2218,rn]

rm(rD,olap.plt,nnsvg_ranks,nnsvg_res_list)
gc(full=T)

vargenes <- as.data.table(splc2.2218svgs)
vargenes <- cbind(vargenes,splc2.hsvgs,c(splc2.hvgs,rep("",nrow(vargenes)-length(splc2.hvgs))),c(splc2.svgs,rep("",nrow(vargenes)-length(splc2.svgs))))
setnames(vargenes,c("svgs2k","HandSvgs","hvgs","svgs"))
# write.table(vargenes,"Top 1310 ea SVGs and HVGs, union, and n union top SVGs.txt",sep='\t',quote=F,row.names=F,col.names=T)
```


### so we can see that the majority of super-SVGs are also considered HVGs, whereas these drop to about 50% to 30 % shared as we consider more of each, confirming that the two datatypes (have potential to) confer distinct information.

